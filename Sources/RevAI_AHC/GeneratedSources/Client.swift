// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// Asynchronous Speech-To-Text API Documentation
///
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Get Job By Id
    ///
    /// Returns information about a transcription job
    ///
    /// - Remark: HTTP `GET /jobs/{id}`.
    /// - Remark: Generated from `#/paths//jobs/{id}/get(GetJobById)`.
    public func GetJobById(_ input: Operations.GetJobById.Input) async throws -> Operations.GetJobById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetJobById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/jobs/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetJobById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncTranscriptionJob.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses.Unauthorized.Body.application_problem_plus_jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.JobNotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseProblemDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Job by Id
    ///
    /// Deletes a transcription job. All data related to the job, such as input media and transcript, will be permanently deleted. A job can only be deleted once it's completed (either with success or failure).
    ///
    /// - Remark: HTTP `DELETE /jobs/{id}`.
    /// - Remark: Generated from `#/paths//jobs/{id}/delete(DeleteJobById)`.
    public func DeleteJobById(_ input: Operations.DeleteJobById.Input) async throws -> Operations.DeleteJobById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.DeleteJobById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/jobs/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses.Unauthorized.Body.application_problem_plus_jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.JobNotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseProblemDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.DeleteJobById.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InvalidStateDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get List of Jobs
    ///
    /// Gets a list of transcription jobs submitted within the last 30 days in reverse chronological order up to the provided `limit` number of jobs per call. **Note:** Jobs older than 30 days will not be listed. Pagination is supported via passing the last job `id` from a previous call into `starting_after`.
    ///
    /// - Remark: HTTP `GET /jobs`.
    /// - Remark: Generated from `#/paths//jobs/get(GetListOfJobs)`.
    public func GetListOfJobs(_ input: Operations.GetListOfJobs.Input) async throws -> Operations.GetListOfJobs.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetListOfJobs.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/jobs",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "starting_after",
                    value: input.query.starting_after
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetListOfJobs.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.AsyncTranscriptionJob].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetListOfJobs.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BadRequestProblemDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses.Unauthorized.Body.application_problem_plus_jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Submit Transcription Job
    ///
    /// Starts an asynchronous job to transcribe speech-to-text for a media file. Media files can be specified in two ways, either by including a public url to the media in the transcription job `options` or by uploading a local file as part of a multipart/form request.
    ///
    /// - Remark: HTTP `POST /jobs`.
    /// - Remark: Generated from `#/paths//jobs/post(SubmitTranscriptionJob)`.
    public func SubmitTranscriptionJob(_ input: Operations.SubmitTranscriptionJob.Input) async throws -> Operations.SubmitTranscriptionJob.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SubmitTranscriptionJob.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/jobs",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "media",
                            "options"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .media(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "application/octet-stream"
                                )
                                return .init(
                                    name: "media",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .options(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsJSON(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "application/json; charset=utf-8"
                                )
                                return .init(
                                    name: "options",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SubmitTranscriptionJob.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncTranscriptionJob.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SubmitTranscriptionJob.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BadRequestProblemDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses.Unauthorized.Body.application_problem_plus_jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                case 413:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.PayloadTooLarge.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses.PayloadTooLarge.Body.application_problem_plus_jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .contentTooLarge(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transcript By Id
    ///
    /// Returns the transcript for a completed transcription job. Transcript can be returned as either JSON or plaintext format. Transcript output format can be specified in the `Accept` header. Returns JSON by default.
    /// ***
    /// Note: For streaming jobs, transient failure of our storage during a live session may prevent the final hypothesis elements from saving properly, resulting in an incomplete transcript. This is rare, but not impossible. To guarantee 100% completeness, we recommend capturing all final hypothesis when you receive them on the client.
    ///
    ///
    /// - Remark: HTTP `GET /jobs/{id}/transcript`.
    /// - Remark: Generated from `#/paths//jobs/{id}/transcript/get(GetTranscriptById)`.
    public func GetTranscriptById(_ input: Operations.GetTranscriptById.Input) async throws -> Operations.GetTranscriptById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetTranscriptById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/jobs/{}/transcript",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetTranscriptById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/vnd.rev.transcript.v1.0+json",
                            "text/plain"
                        ]
                    )
                    switch chosenContentType {
                    case "application/vnd.rev.transcript.v1.0+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Transcript.self,
                            from: responseBody,
                            transforming: { value in
                                .application_vnd_period_rev_period_transcript_period_v1_period_0_plus_json(value)
                            }
                        )
                    case "text/plain":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .plainText(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses.Unauthorized.Body.application_problem_plus_jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.JobNotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseProblemDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 406:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.InvalidTranscriptFormat.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses.InvalidTranscriptFormat.Body.application_problem_plus_jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notAcceptable(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetTranscriptById.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InvalidStateDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Captions
    ///
    /// Returns the caption output for a transcription job. We currently support SubRip (SRT) and Web Video Text Tracks (VTT) output.
    /// Caption output format can be specified in the `Accept` header. Returns SRT by default.
    /// ***
    /// Note: For streaming jobs, transient failure of our storage during a live session may prevent the final hypothesis elements from saving properly, resulting in an incomplete caption file. This is rare, but not impossible.
    ///
    ///
    /// - Remark: HTTP `GET /jobs/{id}/captions`.
    /// - Remark: Generated from `#/paths//jobs/{id}/captions/get(GetCaptions)`.
    public func GetCaptions(_ input: Operations.GetCaptions.Input) async throws -> Operations.GetCaptions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetCaptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/jobs/{}/captions",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "speaker_channel",
                    value: input.query.speaker_channel
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetCaptions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/x-subrip",
                            "text/vtt"
                        ]
                    )
                    switch chosenContentType {
                    case "application/x-subrip":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_x_hyphen_subrip(value)
                            }
                        )
                    case "text/vtt":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .text_vtt(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses.Unauthorized.Body.application_problem_plus_jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.JobNotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseProblemDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 405:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.InvalidJobPropertyCaptions.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses.InvalidJobPropertyCaptions.Body.application_problem_plus_jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .methodNotAllowed(.init(body: body))
                case 406:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.InvalidCaptionFormat.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses.InvalidCaptionFormat.Body.application_problem_plus_jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notAcceptable(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetCaptions.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InvalidStateDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Account
    ///
    /// Get the developer's account information
    ///
    /// - Remark: HTTP `GET /account`.
    /// - Remark: Generated from `#/paths//account/get(GetAccount)`.
    public func GetAccount(_ input: Operations.GetAccount.Input) async throws -> Operations.GetAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/account",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetAccount.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Account.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses.Unauthorized.Body.application_problem_plus_jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .application_problem_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
